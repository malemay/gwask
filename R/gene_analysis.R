#' Extract signal ranges from GWAS results
#'
#' This function takes a data.frame of GWAS association data
#' formatted with either \code{\link{format_kmer_gwas}} or
#' \code{\link{format_gapit_data}} and groups contiguous
#' significant associations into the same GenomicRanges
#' object (given some criteria) so that it can be used
#' to query the genome e.g. for overlapping genes or variants.
#'
#' @param formatted_data A data.frame of formatted GWAS association
#'   data as generated by \code{\link{format_kmer_gwas}} or
#'   \code{\link{format_gapit_data}}.
#' @param threshold Numeric. The minimum -log10(p-value) to consider
#'   as a significant association
#' @param distance Numeric. The maximum distance (in base pairs) that
#'   two ranges must be for them to be merged into the same signal.
#'
#' @return A GenomicRanges object with the grouped signals
#' 
#' @export
#' @examples
#' NULL
extract_signals <- function(formatted_data, threshold, distance = 10^5) {
	# Checking that formatted_data has the right format
	if(!all(c("manhattan_chrom", "manhattan_rpos", "manhattan_cpos", "manhattan_log10p", "manhattan_even") %in% names(formatted_data))) {
		stop("The formatted_data data.frame does not satisfy format requirements.")
	}

	# Checking the validity of the threhsold
	if(threshold < 0) stop("The threshold must be greater than 0.")

	# Subsetting to keep only significant associations
	formatted_data <- formatted_data[formatted_data$manhattan_log10p >= threshold, ]

	# We return an empty GRanges if no associations are left
	if(!nrow(formatted_data)) return(GRanges())

	# Coercing the formatted data into a GRanges object
	formatted_data <- makeGRangesFromDataFrame(formatted_data,
								  keep.extra.columns = TRUE,
								  seqnames.field = "manhattan_chrom",
								  start.field = "manhattan_cpos",
								  end.field = "manhattan_cpos")

	# We then reduce this GRanges object by merging all GRanges that are separated by less than distance bp
	output <- reduce(formatted_data, min.gapwidth = as.integer(distance), with.revmap = TRUE)

	# Generating a unique signal identifier
	output$signal_id <- paste0(seqnames(output), "_", as.character(start(output)), "_", as.character(end(output)))

	# We add some metadata columns to the output
	output$n_markers <- lengths(extractList(formatted_data, output$revmap))
	output$log10_p <- sapply(extractList(formatted_data, output$revmap), function(x) max(x$manhattan_log10p))
	if("MAPQ" %in% names(mcols(formatted_data))) output$MAPQ <- sapply(extractList(formatted_data, output$revmap), function(x) max(x$MAPQ))
	output$max_marker <- sapply(extractList(formatted_data, output$revmap), function(x) x$ref_pos[which.max(x$manhattan_log10p)])

	output
}

#' Check the overlap between newly-discovered signals and known signals
#'
#' @param new_signals A GRanges object with the description of newly discovered signals
#' @param known_signals A data.frame object with the following metadata columns
#'   (this data.frame will be coerced to a GRanges object internally: eventually
#'   signals should be uniformly represented a GRanges throughout the package for
#'   a cleaner interface)
#'   (accessible through the \code{mcols} function :
#'   \itemize{
#'     \item signal_key: the character key used to uniquely identify this signal
#'     \item n_snps: the number of SNPs associated with that signal in the original study
#'     \item log_pvalue: the maximum -log10(p-value) observed for all associated SNPs
#'     \item max_pos: the position along the reference where the most significant p-value occurs
#'     \item locus: the name by which the locus is typically referred to
#'     \item glyma_name: the standardized name by which the gene is known
#'     \item common_name: the name by which the gene is commonly known
#'     \item size: the length of the gene
#'   }
#' 
#' @return a list of two GRanges object. The first element of the list
#'   is a GRanges similar to new_signals but with added metadata columns
#'   with information about the matches that were found in known_signals.
#'   Values are NA where no match was found (or the value was already NA
#'   in known_signals). The second element of the list is similar except
#'   that it gives the information on known_signals and the new_signals
#'   that overlapped them.
#'
#' @export
#' @examples
#' NULL
compare_signals <- function(new_signals, known_signals) {

	# Representing the known signals as a GRanges object
	known_signals <- makeGRangesFromDataFrame(known_signals[, !names(known_signals) %in% c("start", "end")],
							       keep.extra.columns = TRUE,
							       ignore.strand = TRUE,
							       seqnames.field = "first_chrom",
							       start.field = "first_pos",
							       end.field = "last_pos")

	# Finding the overlap between the two GRanges
	# suppressWarnings() is used here because the seqlevels are not the same for both sequences: this should be fixed
	suppressWarnings(signal_overlaps <- findOverlaps(new_signals, known_signals))

	# Checking that at most one known_signal was found per new_signal
	stopifnot(all(table(queryHits(signal_overlaps) == 1)))

	# Inserting the key of the known_signals
	new_signals$known_signal <- NA
	new_signals$known_signal[queryHits(signal_overlaps)] <- mcols(known_signals)[subjectHits(signal_overlaps), "signal_key"]

	new_signals$signal_start <- NA
	new_signals$signal_width <- NA
	new_signals$signal_end <- NA

	new_signals$signal_start[queryHits(signal_overlaps)] <- start(known_signals)[subjectHits(signal_overlaps)]
	new_signals$signal_width[queryHits(signal_overlaps)] <- width(known_signals)[subjectHits(signal_overlaps)]
	new_signals$signal_end[queryHits(signal_overlaps)] <- end(known_signals)[subjectHits(signal_overlaps)]

	for(variable in c("signal_key", "n_snps", "log_pvalue", "max_pos", "locus", "glyma_name", "common_name", "size")) {
		mcols(new_signals)[[variable]] <- NA
		mcols(new_signals)[[variable]][queryHits(signal_overlaps)] <- mcols(known_signals)[subjectHits(signal_overlaps), variable]
	}

	# Now finding which known signals are being overlapped by the new signals
	suppressWarnings(signal_overlaps <- findOverlaps(known_signals, new_signals))
	stopifnot(all(table(queryHits(signal_overlaps) == 1)))

	# Inserting the id of the new_signals
	known_signals$new_signal <- NA
	known_signals$new_signal[queryHits(signal_overlaps)] <- mcols(new_signals)[subjectHits(signal_overlaps), "signal_id"]

	known_signals$signal_start <- NA
	known_signals$signal_width <- NA
	known_signals$signal_end <- NA

	known_signals$signal_start[queryHits(signal_overlaps)] <- start(new_signals)[subjectHits(signal_overlaps)]
	known_signals$signal_width[queryHits(signal_overlaps)] <- width(new_signals)[subjectHits(signal_overlaps)]
	known_signals$signal_end[queryHits(signal_overlaps)] <- end(new_signals)[subjectHits(signal_overlaps)]

	for(variable in c("signal_id", "n_markers", "log10_p", "max_marker")) {
		mcols(known_signals)[[variable]] <- NA
		mcols(known_signals)[[variable]][queryHits(signal_overlaps)] <- mcols(new_signals)[subjectHits(signal_overlaps), variable]
	}

	list(new_signals, known_signals)
}


#' Get the genes associated with a set of GWAS signals
#'
#' @param signals A GRanges object of significant GWAS signals, as output
#'   by the function \code{\link{extract_signals}}.
#' @param genes A GRanges object describing the set of genes in the organism
#'   of interest, as returned by the function \code{\link[GenomicFeatures]{genes}}
#'
#' @return To be completed
#'
#' @export
#' @examples
#' NULL
extract_genes <- function(signals, genes) {
	findOverlaps(signals, genes)
}

#' Get the signed distance between a gene and markers in a signal
#'
#' This function takes a set of signals found by a GWAS analysis
#' and extracts the one (if any) that overlaps a gene of interest.
#' If there is one such signal, then the distance from all the
#' markers in that signal and the gene of interest is computed and
#' returned.
#'
#' @param signals A GRanges object of GWAS signals to check for potential
#'   overlaps with the genes.
#' @param markers A data.frame of markers used in GWAS.
#' @param gene_id A character. The name of a gene in the set of genes
#'   to check for overlaps.
#' @param genes A GRanges object containing the positions of genes to
#'   look for.
#'
#' @return A GRanges object of the same form as the markers data.frame
#'   but with an added column "distance" showing the (signed) distance
#'   from each marker to the gene of interest. Only the markers in the
#'   signal that overlaps the genes are returned. If none of the signals
#'   or no markers are located in the interval of interest, then an empty
#'   GRanges object is returned.
#'
#' @export
#' @examples
#' NULL
gene_distance <- function(signals, markers, gene_id, genes) {
	# Checking for the validity of the inputs
	if(!(inherits(signals, "GRanges"))) {
		stop("The signals object must inherit from GRanges")
	}

	if(!(inherits(genes, "GRanges"))) {
		stop("The genes object must inherit from GRanges")
	}

	if(!gene_id %in% names(genes)) {
		stop("gene_id not among the set of genes provided")
	}

	# Translating the markers object into a GenomicRanges object
	markers <- GenomicRanges::makeGRangesFromDataFrame(markers,
							   keep.extra.columns = TRUE,
							   ignore.strand = TRUE,
							   seqnames.field = "RNAME",
							   start.field = "manhattan_cpos",
							   end.field = "manhattan_cpos")

	# Now we extract the signal that overlaps the gene
	overlapping_signal <- IRanges::subsetByOverlaps(signals, genes[gene_id])
	if(!length(overlapping_signal)) return(GRanges())

	# And then we use this signal to retrieve the markers located in that region
	markers <- IRanges::subsetByOverlaps(markers, overlapping_signal)
	if(!length(markers)) return(GRanges())

	# We add a column with the distance to the gene in the markers GRanges object
	markers$distance <- GenomicRanges::distance(markers, genes[gene_id])
	# We want the signed distance (expressed in terms of reference coordinates and not gene orientation)
	markers$distance <- ifelse(start(markers) < start(genes[gene_id]), -markers$distance, markers$distance)

	return(markers)
}

