#' Extract signal ranges from GWAS results
#'
#' This function takes a GRanges object of GWAS association data
#' formatted with either \code{\link{format_kmer_gwas}} or
#' \code{\link{format_gapit_data}} and groups contiguous
#' significant associations into the same GRanges
#' object (given some criteria) so that it can be used
#' to query the genome e.g. for overlapping genes or variants.
#'
#' @param markers A GRanges object of formatted GWAS association
#'   data as generated by \code{\link{format_kmer_gwas}} or
#'   \code{\link{format_gapit_data}}.
#' @param threshold Numeric. The minimum -log10(p-value) to consider
#'   as a significant association
#' @param distance Numeric. The maximum distance (in base pairs) that
#'   two ranges must be for them to be merged into the same signal.
#'
#' @return A GenomicRanges object with the grouped signals. The metadata
#'   columns "MAPQ" and "log10p" in the output GRanges represent the 
#'   maximum values across all markers in the signal.
#' 
#' @export
#' @examples
#' NULL
extract_signals <- function(markers, threshold, distance = 10^5) {
	# Checking that markers has the right format
	if(!(inherits(markers, "GRanges") && "log10p" %in% names(mcols(markers)))) {
		stop("The 'markers' parameter does not satisfy formatting requirements.")
	}

	# Checking the validity of the threhsold and subsetting for significant associations
	if(threshold < 0) stop("The threshold must be greater than 0.")
	markers <- markers[markers$log10p >= threshold]

	# We return an empty GRanges if no associations are left
	if(!length(markers)) return(markers)

	# We then reduce this GRanges object by merging all GRanges that are separated by less than distance bp
	output <- reduce(markers, min.gapwidth = as.integer(distance), with.revmap = TRUE, ignore.strand = TRUE)

	# Generating a unique signal identifier
	output$signal_id <- paste0(seqnames(output), "_", as.character(start(output)), "_", as.character(end(output)))

	# We add some metadata columns to the output
	output$n_markers <- lengths(extractList(markers, output$revmap))
	output$log10_p <- sapply(extractList(markers, output$revmap), function(x) max(x$log10p))
	if("MAPQ" %in% names(mcols(markers))) output$MAPQ <- sapply(extractList(markers, output$revmap), function(x) max(x$MAPQ))
	output$max_marker <- sapply(extractList(markers, output$revmap), function(x) x$ref_pos[which.max(x$log10p)])

	return(output)
}

#' Check the overlap between newly-discovered signals and known signals
#'
#' @param new_signals A GRanges object with the description of newly discovered signals
#' @param known_signals A data.frame object with the following metadata columns
#'   (this data.frame will be coerced to a GRanges object internally: eventually
#'   signals should be uniformly represented a GRanges throughout the package for
#'   a cleaner interface)
#'   (accessible through the \code{mcols} function :
#'   \itemize{
#'     \item signal_key: the character key used to uniquely identify this signal
#'     \item n_snps: the number of SNPs associated with that signal in the original study
#'     \item log_pvalue: the maximum -log10(p-value) observed for all associated SNPs
#'     \item max_pos: the position along the reference where the most significant p-value occurs
#'     \item locus: the name by which the locus is typically referred to
#'     \item glyma_name: the standardized name by which the gene is known
#'     \item common_name: the name by which the gene is commonly known
#'     \item size: the length of the gene
#'   }
#' 
#' @return a list of two GRanges object. The first element of the list
#'   is a GRanges similar to new_signals but with added metadata columns
#'   with information about the matches that were found in known_signals.
#'   Values are NA where no match was found (or the value was already NA
#'   in known_signals). The second element of the list is similar except
#'   that it gives the information on known_signals and the new_signals
#'   that overlapped them.
#'
#' @export
#' @examples
#' NULL
compare_signals <- function(new_signals, known_signals) {

	# Representing the known signals as a GRanges object
	known_signals <- makeGRangesFromDataFrame(known_signals[, !names(known_signals) %in% c("start", "end")],
							       keep.extra.columns = TRUE,
							       ignore.strand = TRUE,
							       seqnames.field = "first_chrom",
							       start.field = "first_pos",
							       end.field = "last_pos")

	# Finding the overlap between the two GRanges
	# suppressWarnings() is used here because the seqlevels are not the same for both sequences: this should be fixed
	suppressWarnings(signal_overlaps <- findOverlaps(new_signals, known_signals))

	# Checking that at most one known_signal was found per new_signal
	stopifnot(all(table(queryHits(signal_overlaps) == 1)))

	# Inserting the key of the known_signals
	new_signals$known_signal <- NA
	new_signals$known_signal[queryHits(signal_overlaps)] <- mcols(known_signals)[subjectHits(signal_overlaps), "signal_key"]

	new_signals$signal_start <- NA
	new_signals$signal_width <- NA
	new_signals$signal_end <- NA

	new_signals$signal_start[queryHits(signal_overlaps)] <- start(known_signals)[subjectHits(signal_overlaps)]
	new_signals$signal_width[queryHits(signal_overlaps)] <- width(known_signals)[subjectHits(signal_overlaps)]
	new_signals$signal_end[queryHits(signal_overlaps)] <- end(known_signals)[subjectHits(signal_overlaps)]

	for(variable in c("signal_key", "n_snps", "log_pvalue", "max_pos", "locus", "glyma_name", "common_name", "size")) {
		mcols(new_signals)[[variable]] <- NA
		mcols(new_signals)[[variable]][queryHits(signal_overlaps)] <- mcols(known_signals)[subjectHits(signal_overlaps), variable]
	}

	# Now finding which known signals are being overlapped by the new signals
	suppressWarnings(signal_overlaps <- findOverlaps(known_signals, new_signals))
	stopifnot(all(table(queryHits(signal_overlaps) == 1)))

	# Inserting the id of the new_signals
	known_signals$new_signal <- NA
	known_signals$new_signal[queryHits(signal_overlaps)] <- mcols(new_signals)[subjectHits(signal_overlaps), "signal_id"]

	known_signals$signal_start <- NA
	known_signals$signal_width <- NA
	known_signals$signal_end <- NA

	known_signals$signal_start[queryHits(signal_overlaps)] <- start(new_signals)[subjectHits(signal_overlaps)]
	known_signals$signal_width[queryHits(signal_overlaps)] <- width(new_signals)[subjectHits(signal_overlaps)]
	known_signals$signal_end[queryHits(signal_overlaps)] <- end(new_signals)[subjectHits(signal_overlaps)]

	for(variable in c("signal_id", "n_markers", "log10_p", "max_marker")) {
		mcols(known_signals)[[variable]] <- NA
		mcols(known_signals)[[variable]][queryHits(signal_overlaps)] <- mcols(new_signals)[subjectHits(signal_overlaps), variable]
	}

	list(new_signals, known_signals)
}


#' Get the genes associated with a set of GWAS signals
#'
#' @param signals A GRanges object of significant GWAS signals, as output
#'   by the function \code{\link{extract_signals}}.
#' @param genes A GRanges object describing the set of genes in the organism
#'   of interest, as returned by the function \code{\link[GenomicFeatures]{genes}}
#'
#' @return To be completed
#'
#' @export
#' @examples
#' NULL
extract_genes <- function(signals, genes) {
	findOverlaps(signals, genes)
}

#' Get the signed distance between a gene and markers in a signal
#'
#' This function takes a set of signals found by a GWAS analysis
#' and extracts the one (if any) that overlaps a gene of interest.
#' If there is one such signal, then the distance from all the
#' markers in that signal and the gene of interest is computed and
#' returned.
#'
#' @param signals A GRanges object of GWAS signals to check for potential
#'   overlaps with the genes.
#' @param markers A GRanges object of markers used in GWAS.
#' @param gene A GRanges object containing the positions of a gene of
#'   interest. In the current implementation it is an error to pass
#'   a GRanges object with more than one range.
#'
#' @return A GRanges object of the same form as the markers GRanges
#'   but with an added column "distance" showing the (signed) distance
#'   from each marker to the gene of interest. Only the markers in the
#'   signal that overlaps the genes are returned. If none of the signals
#'   or no markers are located in the interval of interest, then an empty
#'   GRanges object is returned.
#'
#' @export
#' @examples
#' NULL
gene_distance <- function(signals, markers, gene) {
	# Checking for the validity of the inputs
	if(!(inherits(signals, "GRanges"))) {
		stop("The signals object must inherit from GRanges")
	}

	if(!(inherits(markers, "GRanges"))) {
		stop("The markers object must inherit from GRanges")
	}

	if(!(inherits(gene, "GRanges"))) {
		stop("The genes object must inherit from GRanges")
	}

	stopifnot(length(gene) == 1)

	# Now we extract the signal that overlaps the gene
	overlapping_signal <- IRanges::subsetByOverlaps(signals, gene)
	if(!length(overlapping_signal)) return(GRanges())

	# And then we use this signal to retrieve the markers located in that region
	markers <- IRanges::subsetByOverlaps(markers, overlapping_signal)
	if(!length(markers)) return(GRanges())

	# We add a column with the distance to the gene in the markers GRanges object
	markers$distance <- GenomicRanges::distance(markers, gene)
	# We want the signed distance (expressed in terms of reference coordinates and not gene orientation)
	markers$distance <- ifelse(start(markers) < start(gene), -markers$distance, markers$distance)

	return(markers)
}

#' Launch a MLM GWAS analysis on a VCF file read with VariantAnnotation::readVcf using GAPIT
#'
#' This function is used as a convenience to quickly launch a GAPIT analysis based on
#' data read with \code{\link[VariantAnnotation]{readVcf}}.
#'
#' @param A CollapsedVcf object read by \code{\link[VariantAnnotation]{readVcf}}.
#' @param kinship A kinship data.frame satisfying the input requirements of GAPIT.
#' @param pca A pca data.frame satisfying the input requirements of GAPIT.
#' @param phenodata A character, the name of a file containing semicolon-separated
#'   phenotypic data
#' @param trait A character, the name of the trait to analyze. Should correspond
#'   to the name of a column in the phenotypic data.
#' @param id_column A character, the name of the column containing the sample IDs
#'   in the phenotypic data. These sample IDs should correspond to those used in the
#'   VCF file.
#' @param tmproot A character. The temporary directory to use as a root for creating
#'   temporary storage.
#' @param ... Other arguments to be passed to GAPIT
#'
#' @return A GRanges object containing the results of the GAPIT analysis.
#' @export
#'
#' @examples
#'NULL
gapit_vcf <- function(vcf, kinship, pca, phenodata, trait, id_column, tmproot, ...) {

	# Converting from VCF format to HapMap format suitable for input to GAPIT
	genotypes <- vcf_to_gapit(vcf)

	# Reading the phenotypic data
	phenotypes <- read.table(phenodata, header = TRUE, sep = ";", stringsAsFactors = FALSE)[, c(id_column, trait)]

	phenotypes <- phenotypes[complete.cases(phenotypes), ]

	colnames(phenotypes) <- c("Taxa", trait)

	# Running GAPIT in a temporary directory so that temporary files can be easily removed afterwards
	tmpdir <- tempfile(tmpdir = tmproot)
	dir.create(tmpdir, recursive = TRUE)

	odir <- setwd(tmpdir)

	gapit_results <- GAPIT3::GAPIT(Y = phenotypes,
				       G = genotypes,
				       KI = kinship,
				       CV = pca,
				       PCA.total = 0,
				       Model.selection = FALSE,
				       model = "MLM",
				       file.output = FALSE,
				       ...)

	# Getting back to the original directory and cleaning
	setwd(odir)
	unlink(tmpdir, recursive = TRUE)

	# Formatting the GAPIT results so they match the expected format
	gapit_results <- gapit_results$GWAS[, c("SNP", "Chromosome", "Position ", "P.value")]

	# WARNING: THIS CHROMOSOME NAMING SCHEME IS SPECIFIC TO SOYBEAN
	gapit_results$Chromosome <- paste0("Gm", ifelse(as.numeric(gapit_results$Chromosome) < 10, "0", ""), gapit_results$Chromosome)
	gapit_results$FDR_Adjusted_P.values <- NA_real_
	gapit_results$log10p <- -log10(gapit_results$P.value)
	gapit_results$pruned <- TRUE

	gapit_results <- GenomicRanges::makeGRangesFromDataFrame(gapit_results,
								 keep.extra.columns = TRUE,
								 ignore.strand = TRUE,
								 seqnames.field = "Chromosome",
								 start.field = "Position ",
								 end.field = "Position ")

	gapit_results
}

#' Convert VCF records read with VariantAnnotation::readVCF into a format usable by GAPIT
#'
#'
#' @param x A CollapsedVCF object as read by \code{\link[VariantAnotation]{readVcf}}
#'
#' @return A data.frame object representing data in HapMap format, suitable for
#'   input as the genotype argument of \code{\link[GAPIT3]{GAPIT}}
#'
#' @examples
#' NULL
vcf_to_gapit <- function(x) {
	n <- length(x)
	id <- c("rs#", names(x))
	alleles <- c("alleles", rep("A/T", n))
	chrom <- c("chrom", as.character(as.numeric(sub("Gm", "", GenomicRanges::seqnames(x)))))
	poscol <- c("pos", as.character(start(x)))
	strandcol <- c("strand", rep("+", n))
	assembly <- c("assembly#", rep(NA_character_, n))
	center <- c("center", rep(NA_character_, n))
	protLSID <- c("protLSID", rep(NA_character_, n))
	assayLSID <- c("assayLSID", rep(NA_character_, n))
	panelLSID <- c("panelLSID", rep(NA_character_, n))
	QCcode <- c("QCcode", rep(NA_character_, n))

	geno_lookup <- c("0/0" = "AA",
			 "0/1" = "AT",
			 "1/0" = "TA",
			 "1/1" = "TT",
			 "./." = "NN")

	genotypes <- matrix(geno_lookup[VariantAnnotation::geno(x)$GT], nrow = n)
	if(any(is.na(genotypes))) stop("Unrecognized GT field")
	genotypes <- rbind(VariantAnnotation::samples(VariantAnnotation::header(x)), genotypes)

	as.data.frame(cbind(id, alleles, chrom, poscol, strandcol, assembly, center, protLSID, assayLSID, panelLSID, QCcode, genotypes))
}

